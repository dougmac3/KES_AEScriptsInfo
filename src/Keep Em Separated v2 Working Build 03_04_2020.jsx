//Keep Em Separated v2.0 - 2020//Created by Douglas McGinness//Separates position and scale dimensions across multiple layers, while preserving keyframe interpolation data. Works on 2D and 3D layers//always use a unique name for the main function as it will live in the global scopefunction dhm_KES(thisObj)    {             var af_settings = {           // THESE SETTINGS ARE MANDATORY            scriptName: "KeepEmSeparated", //This is the name of your product,  best thing to do is to use your global script name variable so they are always in sync            scriptVersion: "2.0", //just the version number, do not add a v.  best thing to do is to use your global script version variable so they are always in sync            scriptAuthor: "Douglas McGinness", // your author name, this will be used in the copyright on the help UI            scriptURL: "https://aescripts.com/keep-em-separated/", //enter the script URL here            privateNumber: 112233, // **THIS IS YOUR SCRIPT'S UNIQUE PRIVATE NUMBER** please get this number from the aescripts admin, every product and major version will need a new number            productSKU: "DHKES-NYOP", // this is the products SKU on the site, ie AESLT-SUL                      // HELP UI VARIABLES ////////            helpText: "Keep ‘Em Separated is a workflow solution to separating position and scale dimensions in After Effects. \n KES can work on multiple 2D or 3D layers at a time and is totally non-destructive, meaning it will transfer existing keyframe animation to the separated dimensions, and back again if you choose to rejoin dimensions. \n For more info please visit aescripts.com/keepemseparated", //You must include some brief instructions on how the tool works, THIS IS MANDATORY. If you don't use the helpUI function, please include the intructions in your UI somewhere.                        // THESE SETTINGS ARE ALL OPTIONAL            helpButtons: [  //optional, You can include up to 3 buttons at the bottom of the help UI. They are defined in an array, if you are not using the helpUI function you do not need to include this variable                //   {name: "Video Tutorial", url: "https://youtu.be/j7Q2bhWSmJk"}, // this object defines the 1st button                //   {name: "Other Products", url: "http://aescripts.com/authors/joe-author"}, // this would be the second button                //only define the buttons you want, up to 3             ],            ////// TRIAL ///////            offerTrial: true, //optional, set to false if you don't want to offer a trial mode, true if you do, defaults to true            // BETA MODE SETTINGS // optional, you only need to include these if you are using the beta mode            offerBeta: true, //set to true if you are distributing the script as a beta test, set the expiration date below, defaults to false            betaStartDate: new Date("Mar 5, 2020"), //Date the beta will start            betaExpirationDate: new Date("Mar 9, 2020"), //Date the beta should expire in this format: "Dec 1, 2017"            betaSupportEmail: "douglas@doug.haus", //optional, so that beta testers can contact you directly        };                //@include "trial_serializaton_generic_v3_mx.jsx"                var dhmK = new a(af_settings); //remember to use a random variable name          if (dhmK.c()) {            var isKBarRunning = (typeof kbar !== 'undefined');            if (isKBarRunning && kbar.button)            {               var version = kbar.version;   // '1.1.1'               var button = kbar.button;  // Make a local copy of the kbar variable and button.               var id = button.id;      // '4d8026d4-956c-4233-8730-3ea2abfaad35'               var name = button.name;  // 'Show off a sample scriptlet'               var argument = button.argument; // Any string value               switch(button.argument)               {                  case '1':                      separateKeyframes();                     break;                  case '2':                     joinKeyframes();                     break;                                        case '3':                      separateScale();                      break;                                         case '4':                      joinScale();                      break;                  default:                     separateKeyframes();                     break;               }            }            else            {            function KeepEmSeparated(thisObj) {                var isTrial = dhmK.t();                var trialLayerLimit = 2;                var numLayers = app.project.activeItem.selectedLayers.length;                                function buildUI(thisObj) {                    var winPanel = (thisObj instanceof Panel) ? thisObj:new Window("palette","Keep 'Em Separated",undefined,{resizable:true,closeButton:true});                                       var res = "group{orientation:'column'},\                    groupOne: Group{orientation:'row',\                    }";                           var scriptPath = File($.fileName).path;                    var joinPic= scriptPath + encodeURI("/Icons/JoinedKeyframe.png");                    var sepPic= scriptPath + encodeURI("/Icons/SeparatedKeyframe.png");                    var infoPic = scriptPath + encodeURI("/Icons/Info.png");                    var scalePic = scriptPath + encodeURI("/Icons/ScaleInfo.png");                    var grp = winPanel.add("group");                            grp.orientation = "column";                    grp.alignment = ["fill", "fill"];                    grp.alignChildren = ["fill", "fill"];                    var radioGroup = grp.add("panel", undefined, "Keep 'Em Separated");                                            var posCheck = radioGroup.add("radiobutton", undefined, "Position");                         var scaleCheck = radioGroup.add("radiobutton", undefined, "Scale");                                        posCheck.helpTip = "Separate Position Dimensions";                    scaleCheck.helpTip = "Separate Scale Dimensions";                    radioGroup.orientation = "row";                    radioGroup.alignChildren = ["fill", "fill"];                    var scaleButton = radioGroup.add("iconbutton",[0,0,0,0],scalePic, {style: "toolbutton"});                    var myPanel2 = grp.add("panel",undefined);                    var sepButton = myPanel2.add("iconbutton", undefined, sepPic, {style: "toolbutton"});                    sepButton.helpTip = "Separate Dimensions";                    var joinButton = myPanel2.add("iconbutton", undefined, joinPic, {style: "toolbutton"});                        joinButton.helpTip = "Join Dimensions";                    myPanel2.orientation = "row";                    myPanel2.alignChildren = ["fill", "fill"];                    posCheck.value = true;                                      sepButton.onClick = function() {buttonHandlingSep(posCheck,scaleCheck)};                    joinButton.onClick = function() {buttonHandlingJoin(posCheck,scaleCheck)};                                       scaleButton.onClick = function() {infoText(scriptPath,1)};                    var groupBottom = winPanel.add("group");                     var reference = groupBottom.add('statictext{text:"by doug haus", justify:"right"}');                    var infoButton = groupBottom.add("iconbutton",[0,0,20,20],infoPic, {style: "toolbutton"});                    infoButton.onClick = function() {infoText(scriptPath,0)};                    winPanel.layout.layout(true);                    return winPanel;                }                              function infoText(scriptPath, value) {                    if (value == 0) {                        var infoText = File(scriptPath + encodeURI("/Icons/InfoText.txt"));                        infoText.open("r");                        alert(infoText.readln());                    } else {                        var scaleText = File(scriptPath + encodeURI("/Icons/ScaleInfo.txt"));                        scaleText.open("r");                        alert(scaleText.readln());                     }                 }                function buttonHandlingSep(posCheck,scaleCheck) {                                        if (posCheck.value == true) {                       separateKeyframes();                    } else if (scaleCheck.value == true) {                       separateScale();                    }                }                 function buttonHandlingJoin(posCheck,scaleCheck) {                                       if (posCheck.value == true) {                       joinKeyframes();                    } else if (scaleCheck.value == true) {                       joinScale();                    }                }                var scriptPal = buildUI(thisObj);                if(scriptPal != null && scriptPal instanceof Window) {                    scriptPal.center();                    scriptPal.show();                }                           }            }            KeepEmSeparated(this);            function separateKeyframes() {                app.beginUndoGroup("Separate Position Dimensions");                function getKeyframes(PropertyVal){                    if(PropertyVal instanceof Property){                        var totalKeys, keyIndexList, IndexKey, ValueKey, keyInType, keyOutType, AutoBez, ContBez, inEase, OutEase, sAutoBez, sContBez, inSpaTang, OutSpaTang, Rover, twoDim, threeDim;                        twoDim = PropertyValueType.TwoD_SPATIAL;                        threeDim = PropertyValueType.ThreeD_SPATIAL;                        keyIndexList = [];                        isTrial = (!dhmK.s());                        totalKeys = PropertyVal.numKeys;                                   if(totalKeys > 0){                            for(var i = 1; i <= totalKeys; i++) {                                keyTimeVar = PropertyVal.keyTime(i);                                IndexKey = i;                                ValueKey = PropertyVal.keyValue(i);                                keyInType = PropertyVal.keyInInterpolationType(IndexKey);                                keyOutType = PropertyVal.keyOutInterpolationType(IndexKey);                                  if(keyInType == KeyframeInterpolationType.BEZIER && keyOutType == KeyframeInterpolationType.BEZIER){                                    AutoBez = PropertyVal.keyTemporalAutoBezier(IndexKey);                                    ContBez = PropertyVal.keyTemporalContinuous(IndexKey);                                }                                                        if(keyInType != KeyframeInterpolationType.HOLD || keyOutType != KeyframeInterpolationType.HOLD){                                    inEase = PropertyVal.keyInTemporalEase(IndexKey);                                    OutEase = PropertyVal.keyOutTemporalEase(IndexKey);                                }                                                          if(PropertyVal.propertyValueType == twoDim || PropertyVal.propertyValueType == threeDim){                                    sAutoBez = PropertyVal.keySpatialAutoBezier(IndexKey);                                    sContBez = PropertyVal.keySpatialContinuous(IndexKey);                                    inSpaTang = PropertyVal.keyInSpatialTangent(IndexKey);                                    OutSpaTang = PropertyVal.keyOutSpatialTangent(IndexKey);                                    Rover = PropertyVal.keyRoving(IndexKey);                                }                                keyIndexList[keyIndexList.length] = {                                    'keyTimeVar':keyTimeVar,                                     'IndexKey':IndexKey,                                     'ValueKeyX':ValueKey[0],                                     'ValueKeyY':ValueKey[1],                                    'ValueKeyZ':ValueKey[2],                                    'ValueKey':ValueKey,                                    'keyInType':keyInType,                                     'keyOutType':keyOutType,                                     'AutoBez':AutoBez,                                     'ContBez':ContBez,                                     'inEase':inEase,                                     'OutEase':OutEase,                                     'sAutoBez':sAutoBez,                                     'sContBez':sContBez,                                     'inSpaTang':inSpaTang,                                     'OutSpaTang':OutSpaTang,                                     'Rover':Rover                                    };                            }                                  return keyIndexList;                        }else{                                      return null;                        }                    }                }                function pasteKeyframes(PropertyVal, KeyArray,num){                    var XorYVal = num;                    if(PropertyVal instanceof Property && KeyArray instanceof Array){                        if(PropertyVal.numKeys == 0){                                 var KeyArrayLength, addNewKey, newKeyIndex;                                 KeyArrayLength = KeyArray.length;                              for(var k = 0; k < KeyArrayLength; k++){                                        addNewKey = PropertyVal.addKey(KeyArray[k].keyTimeVar);                                              newKeyIndex = addNewKey;                                            if (XorYVal == 0) {                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyX);                                  } else if (XorYVal == 1){                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyY);                                  } else {                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyZ);                                }                                  if(KeyArray[k].keyOutType != KeyframeInterpolationType.HOLD){                                    PropertyVal.setTemporalEaseAtKey(newKeyIndex, KeyArray[k].inEase, KeyArray[k].OutEase);                                }                                      PropertyVal.setInterpolationTypeAtKey(newKeyIndex, KeyArray[k].keyInType, KeyArray[k].keyOutType);                                                               if((KeyArray[k].keyInType == KeyframeInterpolationType.BEZIER) && (KeyArray[k].keyOutType == KeyframeInterpolationType.BEZIER)){                                    PropertyVal.setTemporalContinuousAtKey(newKeyIndex, KeyArray[k].ContBez);                                    PropertyVal.setTemporalAutoBezierAtKey(newKeyIndex, KeyArray[k].AutoBez);                                }                                                                        if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                    PropertyVal.setSpatialContinuousAtKey(newKeyIndex, KeyArray[k].sContBez);                                    PropertyVal.setSpatialAutoBezierAtKey(newKeyIndex, KeyArray[k].sAutoBez);                                    PropertyVal.setSpatialTangentsAtKey(newKeyIndex, KeyArray[k].inSpaTang, KeyArray[k].OutSpaTang);                                }                            }                                   if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                for(var r = 0; r < KeyArrayLength; r++){                                    PropertyVal.setRovingAtKey((r+1), KeyArray[r].Rover);                                }                            }                            return true;                    }                }                }                function deleteKeyframes(PropertyVal){                    if(PropertyVal instanceof Property){                        while(PropertyVal.numKeys > 0){                            PropertyVal.removeKey(1);                        }                    }                }                var compLayer = app.project.activeItem;                var activeLayer = compLayer.selectedLayers;                if (activeLayer == null) {                    alert("Please select a layer");                    } else {                            if (isTrial && numLayers > trialLayerLimit) {                                alert("The trial version is limited to "+trialLayerLimit+" layers at a time/nOnly the first "+trialLayerLimit+" layers will be separated");                                numLayers = trialLayerLimit;                             }                            for (var i=0; i<numLayers; i++) {                                   if (activeLayer[i].property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated == true) {                                        alert("Position dimensions are already separated");                                   } else {                                       if (activeLayer[i].property("ADBE Transform Group").property("ADBE Position").numKeys==0){                                            activeLayer[i].property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated = true;                                        } else {                                            var xKey,yKey,zKey;                                            var oldKeys = getKeyframes (activeLayer[i].property("ADBE Transform Group").property("ADBE Position"));                                            if (activeLayer[i].threeDLayer == false) {                                                activeLayer[i].property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated = true;                                                                                      xKey = activeLayer[i].property("ADBE Transform Group").property("ADBE Position").getSeparationFollower(0);                                                yKey = activeLayer[i].property("ADBE Transform Group").property("ADBE Position").getSeparationFollower(1);                                                deleteKeyframes(xKey);                                                deleteKeyframes(yKey);                                                pasteKeyframes (xKey, oldKeys,0);                                                pasteKeyframes(yKey, oldKeys,1);                                            } else if (activeLayer[i].threeDLayer == true) {                                                activeLayer[i].property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated = true;                                                                                                xKey = activeLayer[i].property("ADBE Transform Group").property("ADBE Position").getSeparationFollower(0);                                                yKey = activeLayer[i].property("ADBE Transform Group").property("ADBE Position").getSeparationFollower(1);                                                zKey = activeLayer[i].property("ADBE Transform Group").property("ADBE Position").getSeparationFollower(2);                                                deleteKeyframes(xKey);                                                deleteKeyframes(yKey);                                                deleteKeyframes(zKey);                                                pasteKeyframes (xKey, oldKeys,0);                                                pasteKeyframes(yKey, oldKeys,1);                                                pasteKeyframes(zKey,oldKeys,2);                                            }                                        }                                    }                             }                           }                                app.endUndoGroup();            }            function joinKeyframes() {                app.beginUndoGroup("Join Separated Dimensions");                function getKeyframestoJoin(PropertyVal,threeD){                    if(PropertyVal instanceof Property){                        var totalKeys, curZkey, keyIndexList, IndexKey, ValueKey, keyInTypeX, keyInTypeY, keyOutTypeX, keyOutTypeY, AutoBez, ContBez, inEase, OutEase, sAutoBez, sContBez, inSpaTang, OutSpaTang, Rover, twoDim, threeDim;                        twoDim = PropertyValueType.TwoD_SPATIAL;                        threeDim = PropertyValueType.ThreeD_SPATIAL;                        keyIndexList = [];                        var curXkey = PropertyVal.getSeparationFollower(0);                        var curYkey = PropertyVal.getSeparationFollower(1);                        if (threeD == true) {                            curZkey = PropertyVal.getSeparationFollower(2);                        }                         if (threeD == false) {                            if (curXkey.numKeys != curYkey.numKeys) {                                if (curXkey.numKeys == 0 || curYkey.numKeys == 0) {                                    if (curXkey.numKeys == 0) {                                        evaluateKeys(PropertyVal, 0,0);                                          totalKeys = curYkey.numKeys;                                    } else if (curYkey.numKeys == 0) {                                        evaluateKeys(PropertyVal,1,0);                                           totalKeys = curXkey.numKeys;                                    }                                } else {                                    totalKeys = fillOutKeys(PropertyVal, false);                                }                            } else {                                totalKeys = Math.max(curXkey.numKeys,curYkey.numKeys);                           }                        } else {                            if (Math.min(curXkey.numKeys,curYkey.numKeys,curZkey.numKeys) != Math.max(curXkey.numKeys,curYkey.numKeys,curZkey.numKeys) ){                                if (curXkey.numKeys == 0 || curYkey.numKeys == 0 || curZkey.numKeys == 0) {                                    if (curXkey.numKeys == 0) {                                        if (curYkey.numKeys == 0) {                                            evaluateKeys(PropertyVal, 0,2);                                            totalKeys = curZkey.numKeys;                                        } else if (curZkey.numKeys == 0) {                                            evaluateKeys(PropertyVal,0,1);                                            totalKeys = curYkey.numKeys;                                        } else {                                            evaluateKeys(PropertyVal,0,0);                                            totalKeys = Math.max(curZkey.numKeys,curYkey.numKeys);                                        }                                    } else if (curYkey.numKeys == 0) {                                        if (curZkey.numKeys == 0) {                                            evaluateKeys(PropertyVal,0,3);                                            totalKeys = curXkey.numKeys;                                        } else {                                            evaluateKeys(PropertyVal,1,0);                                            totalKeys = Math.max(curXkey.numKeys,curZkey.numKeys);                                        }                                    } else {                                        evaluateKeys(PropertyVal,0,4);                                        totalKeys = Math.max(curXkey.numKeys,curYkey.numKeys);                                    }                                } else {                                    totalKeys = fillOutKeys(PropertyVal,true);                                }                            } else {                                totalKeys = Math.max(curXkey.numKeys,curYkey.numKeys, curZkey.numKeys);                            }                        }                        if(totalKeys > 0 && PropertyVal.dimensionsSeparated == true){                            var filledOut = false;                            for(var i = 1; i <= totalKeys; i++){                                keyTimeVar = PropertyVal.keyTime(i);                                var curXtime = curXkey.keyTime(i);                                var curYtime = curYkey.keyTime(i);                                if (threeD == true) {                                    var curZtime = curZkey.keyTime(i);                                }                                IndexKey = i;                                   if (threeD == false) {                                    if (curXtime != curYtime && filledOut == false) {                                        totalKeys = fillOutKeys(PropertyVal,false);                                        filledOut = true;                                        keyTimeVar = PropertyVal.keyTime(i);                                    }                                 } else {                                    if ((curXtime != curYtime && filledOut == false) || (curXtime != curZtime && filledOut == false) || (curYtime != curZtime && filledOut == false)) {                                        totalKeys = fillOutKeys(PropertyVal,true);                                        filledOut = true;                                        keyTimeVar = PropertyVal.keyTime(i);                                                              }                                }                                keyInTypeX = curXkey.keyInInterpolationType(IndexKey);                                keyOutTypeX = curXkey.keyOutInterpolationType(IndexKey);                                 keyInTypeY = curYkey.keyInInterpolationType(IndexKey);                                keyOutTypeY = curYkey.keyInInterpolationType(IndexKey);                                ValueKey = PropertyVal.keyValue(i);                                if(keyInTypeX == KeyframeInterpolationType.BEZIER && keyOutTypeX == KeyframeInterpolationType.BEZIER){                                    AutoBez = curXkey.keyTemporalAutoBezier(IndexKey);                                    ContBez = curXkey.keyTemporalContinuous(IndexKey);                                }                                    if(keyInTypeY == KeyframeInterpolationType.BEZIER && keyOutTypeY == KeyframeInterpolationType.BEZIER){                                    AutoBez = curYkey.keyTemporalAutoBezier(IndexKey);                                    ContBez = curYkey.keyTemporalContinuous(IndexKey);                                }                                    if(keyInTypeX != KeyframeInterpolationType.HOLD || keyOutTypeX != KeyframeInterpolationType.HOLD){                                    inEase = curXkey.keyInTemporalEase(IndexKey);                                    OutEase = curXkey.keyOutTemporalEase(IndexKey);                                }                                     if(keyInTypeY != KeyframeInterpolationType.HOLD || keyOutTypeY != KeyframeInterpolationType.HOLD){                                    inEaseY = curYkey.keyInTemporalEase(IndexKey);                                    OutEaseY = curYkey.keyInTemporalEase(IndexKey);                                }                                if(PropertyVal.propertyValueType == twoDim || PropertyVal.propertyValueType == threeDim){                                    sAutoBez = PropertyVal.keySpatialAutoBezier(IndexKey);                                    sContBez = PropertyVal.keySpatialContinuous(IndexKey);                                    inSpaTang = PropertyVal.keyInSpatialTangent(IndexKey);                                    OutSpaTang = PropertyVal.keyOutSpatialTangent(IndexKey);                                    Rover = PropertyVal.keyRoving(IndexKey);                                }                                  var numbKeys = Math.max(curXkey.numKeys,curYkey.numKeys);                                keyIndexList[keyIndexList.length] = {                                    'keyTimeVar':keyTimeVar,                                     'IndexKey':IndexKey,                                     'numbKeys':numbKeys,                                    'ValueKeyX':ValueKey[0],                                     'ValueKeyY':ValueKey[1],                                    'ValueKey':ValueKey,                                    'keyInTypeX':keyInTypeX,                                     'keyOutTypeX':keyOutTypeX,                                    'keyInTypeY':keyInTypeY,                                     'keyOutTypeY':keyOutTypeY,                                    'AutoBez':AutoBez,                                     'ContBez':ContBez,                                     'inEase':inEase,                                     'OutEase':OutEase,                                     'inEaseY':inEaseY,                                    'OutEaseY':OutEaseY,                                    'sAutoBez':sAutoBez,                                     'sContBez':sContBez,                                     'inSpaTang':inSpaTang,                                     'OutSpaTang':OutSpaTang,                                     'Rover':Rover                                    };                            }                            return keyIndexList;                          }                        }else{                                                       return null;                        }                    }                               function evaluateKeys(PropertyVal, dimNum1, dimNum2) {                    var curXVal, curYVal, curZVal, curKeyTime, xKeys, yKeys, zKeys;                    if (dimNum2 == 0) {                        if (dimNum1 == 0) {                            yKeys = PropertyVal.getSeparationFollower(1);                            for (var x = 1; x <= yKeys.numKeys; x++) {                                curKeyTime = yKeys.keyTime(x);                                curXVal = PropertyVal.getSeparationFollower(0).valueAtTime(curKeyTime,false);                                PropertyVal.getSeparationFollower(0).setValueAtTime(curKeyTime,curXVal);                                               }                            return PropertyVal.getSeparationFollower(0);                        } else if (dimNum1 == 1) {                            xKeys = PropertyVal.getSeparationFollower(0);                            for (var y = 1; y <= xKeys.numKeys; y++) {                                curKeyTime = xKeys.keyTime(y);                                curYVal = PropertyVal.getSeparationFollower(1).valueAtTime(curKeyTime,false);                                PropertyVal.getSeparationFollower(1).setValueAtTime(curKeyTime,curYVal);                                               }                            return PropertyVal.getSeparationFollower(1);                         }                     } else {                         if (dimNum2 == 2) {                             zKeys = PropertyVal.getSeparationFollower(2);                             for (var za = 1; za <= zKeys.numKeys; za++) {                                 curKeyTime = zKeys.keyTime(za);                                 curXVal = PropertyVal.getSeparationFollower(0).valueAtTime(curKeyTime,false);                                 curYVal = PropertyVal.getSeparationFollower(1).valueAtTime(curKeyTime,false);                                   PropertyVal.getSeparationFollower(0).setValueAtTime(curKeyTime,curXVal);                                 PropertyVal.getSeparationFollower(1).setValueAtTime(curKeyTime,curYVal);                                                  }                            return PropertyVal.getSeparationFollower(2);                         } else if (dimNum2 == 1) {                             yKeys = PropertyVal.getSeparationFollower(1);                             for (var zb = 1; zb <= yKeys.numKeys; zb++) {                                curKeyTime = yKeys.keyTime(zb);                                curXVal = PropertyVal.getSeparationFollower(0).valueAtTime(curKeyTime,false);                                curZVal = PropertyVal.getSeparationFollower(2).valueAtTime(curKeyTime,false);                                PropertyVal.getSeparationFollower(0).setValueAtTime(curKeyTime,curXVal);                                PropertyVal.getSeparationFollower(2).setValueAtTime(curKeyTime,curZVal);                                               }                            return PropertyVal.getSeparationFollower(1);                        } else if (dimNum2 == 3) {                            xKeys = PropertyVal.getSeparationFollower(0);                            for (var zc = 1; zc <= xKeys.numKeys; zc++) {                                curKeyTime = xKeys.keyTime(zc);                                curYVal = PropertyVal.getSeparationFollower(1).valueAtTime(curKeyTime,false);                                curZVal = PropertyVal.getSeparationFollower(2).valueAtTime(curKeyTime,false);                                PropertyVal.getSeparationFollower(1).setValueAtTime(curKeyTime,curYVal);                                PropertyVal.getSeparationFollower(2).setValueAtTime(curKeyTime,curZVal);                                              }                            return PropertyVal.getSeparationFollower(0);                        } else {                            xKeys = PropertyVal.getSeparationFollower(0);                            for (var zd = 1; zd <= xKeys.numKeys; zd++) {                                curKeyTime = xKeys.keyTime(zd);                                curZVal = PropertyVal.getSeparationFollower(2).valueAtTime(curKeyTime,false);                                PropertyVal.getSeparationFollower(2).setValueAtTime(curKeyTime,curZVal);                                               }                            return PropertyVal.getSeparationFollower(0);                        }                                          }                }                Array.prototype.insert = function ( index, item ) {                this.splice( index, 0, item );                };                function fillOutKeys(PropertyVal,threeD) {                    var totalKeys, curXkey, curYkey, curZkey, IndexKey, newIndex, ValueKey;                              var xKeys = PropertyVal.getSeparationFollower(0);                     var yKeys = PropertyVal.getSeparationFollower(1);                     var zKeys;                     if (threeD == true) {                         zKeys = PropertyVal.getSeparationFollower(2);                         totalKeys = Math.max(xKeys.numKeys, yKeys.numKeys,zKeys.numKeys);                         var PropertyVal3 = PropertyVal.getSeparationFollower(2);                     } else {                         zKeys = null;                     }                    var xArray = [], yArray = [], zArray = [];                    var PropertyVal1 = PropertyVal.getSeparationFollower(0);                    var PropertyVal2 = PropertyVal.getSeparationFollower(1);                     totalKeys = Math.max(xKeys.numKeys,yKeys.numKeys);                     if(totalKeys > 0){                                 for (var x = 1; x <= xKeys.numKeys; x++) {                                xArray.push([xKeys.keyValue(x), xKeys.keyTime(x)]);                            }                            for (var y = 1; y <= yKeys.numKeys; y++) {                                yArray.push([yKeys.keyValue(y),yKeys.keyTime(y)]);                            }                            if (threeD == true) {                                for (var z = 1; z <= zKeys.numKeys; z++) {                                    zArray.push([zKeys.keyValue(z),zKeys.keyTime(z)]);                                }                            }                            if (xArray != null && yArray != null) {                            for (i = 0; i < totalKeys; i++) {                                var xKeyData = xArray[i];                                var yKeyData = yArray[i];                                 var zKeyData;                                if (threeD == true) {                                    zKeyData = zArray[i];                                } else {                                    zKeyData = null;                                }                                IndexKey = i;                                var isthereKeyX = false, isthereKeyY = false, isthereKeyZ = false, outofX = false, outofY = false, outofZ = false;                                try {                                    var trial = xArray.length <= i;                                                                       typeof xKeyData[1] !== undefined;                                } catch(err) {                                    outofX = true;                                }                                try {                                    var trial = yArray.length <= i;                                                                       typeof yKeyData[1] !== undefined;                                } catch(err) {                                    outofY = true;                                }                                if (threeD == true) {                                    try {                                        var trial = zArray.length <= i;                                                                                typeof zKeyData[1] !== undefined;                                    } catch(err) {                                        outofZ = true;                                    }                                }                                var newXValue, newYValue, newZValue;                                if (threeD == false) {                                    if (outofX == true || outofY == true) {                                       if (outofX == true) {                                            keyTimeVar = yKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = false;                                            isthereKeyY = true;                                            newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                            curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                            xArray.insert(i, [curXkey,yKeyData[1]]);                                            ValueKey = [curXkey, yKeyData[0]];                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                       } else if (outofY == true) {                                            keyTimeVar = xKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = false;                                            newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1],true));                                                                         curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                                                      yArray.insert(i, [curYkey,xKeyData[1]]);                                                                        totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                          }                                    } else {                                                                   if (xKeyData[1].toFixed(2) == yKeyData[1].toFixed(2)) {                                                                       } else if (xKeyData[1].toFixed(2) > yKeyData[1].toFixed(2)) {                                                                       newIndex = i+1;                                            isthereKeyX = false;                                            isthereKeyY = true;                                            keyTimeVar = yKeyData[1];                                            newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                            curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                            xArray.insert(i, [curXkey,yKeyData[1]]);                                            totalKeys= Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                                                     } else if (yKeyData[1].toFixed(2) > xKeyData[1].toFixed(2)) {                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = false;                                            keyTimeVar = xKeyData[1];                                            newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1],true));                                            curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                            yArray.insert(i, [curYkey,xKeyData[1]]);                                            totalKeys= Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                      }                                                                              }                                } else {                                    if (outofX == true || outofY == true || outofZ == true) {                                       if (outofX == true) {                                           if (outofY == false && outofZ == false) {                                                                                 keyTimeVar = yKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = false;                                                isthereKeyY = true;                                                isthereKeyZ = true;                                                                                  newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                                curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                                                                  xArray.insert(i, [curXkey,yKeyData[1]]);                                                                                 totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                           } else if (outofY == true && outofZ == false) {                                                                               keyTimeVar = zKeyData[1];                                               newIndex = i+1;                                               isthereKeyX = false;                                               isthereKeyY = false;                                               isthereKeyZ = true;                                               newXValue = PropertyVal1.setValueAtTime(zKeyData[1],PropertyVal1.valueAtTime(zKeyData[1],true));                                               newYValue = PropertyVal2.setValueAtTime(zKeyData[1],PropertyVal2.valueAtTime(zKeyData[1],true));                                               curXkey = PropertyVal1.valueAtTime(zKeyData[1], true);                                               curYkey = PropertyVal2.valueAtTime(zKeyData[1], true);                                               xArray.insert(i,[curXkey,zKeyData[1]]);                                               yArray.insert(i,[curYkey,zKeyData[1]]);                                               totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                       } else if (outofY == true) {                                           if (outofZ == false) {                                                                                  keyTimeVar = zKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = true;                                                isthereKeyY = false;                                                isthereKeyZ = true;                                                                                newXValue = PropertyVal1.setValueAtTime(zKeyData[1],PropertyVal1.valueAtTime(zKeyData[1],true));                                                curXkey = PropertyVal1.valueAtTime(zKeyData[1],true);                                                newYValue = PropertyVal2.setValueAtTime(zKeyData[1],PropertyVal2.valueAtTime(zKeyData[1], true));                                                curYkey = PropertyVal2.valueAtTime(zKeyData[1], true);                                                                                 xArray.insert(i,[curXkey,zKeyData[1]]);                                                yArray.insert(i, [curYkey,zKeyData[1]]);                                                                                 totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          } else {                                                                                   keyTimeVar = xKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = true;                                                isthereKeyY = false;                                                isthereKeyZ = false;                                                newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1], true));                                                newZValue = PropertyVal3.setValueAtTime(xKeyData[1],PropertyVal3.valueAtTime(xKeyData[1], true));                                                curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                                curZkey = PropertyVal3.valueAtTime(xKeyData[1],true);                                                yArray.insert(i,[curYkey,xKeyData[1]]);                                                zArray.insert(i,[curZkey,xKeyData[1]]);                                                totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                       } else {                                                                                       keyTimeVar = xKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = true;                                            isthereKeyZ = false;                                                                          newZValue = PropertyVal3.setValueAtTime(xKeyData[1],PropertyVal3.valueAtTime(xKeyData[1],true));                                                                         curZkey = PropertyVal3.valueAtTime(xKeyData[1],true);                                                                        zArray.insert(i, [curZkey,xKeyData[1]]);                                                                         totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                        }                                                                                } else {                                          if (xKeyData[1] == yKeyData[1] == zKeyData[1]) {                                                                        newIndex = i+1;                                               } else {                                                                var notNum = false;                                            try {                                                typeof xKeyData[1] != 'undefined';                                                                               typeof yKeyData[1] != 'undefined';                                                                                   typeof zKeyData[1] != 'undefined';                                                                              } catch(err) {                                                notNum = true;                                            }                                                                      var minTime = 0;                                            if (notNum == false) {                                                minTime = Math.min(xKeyData[1], yKeyData[1], zKeyData[1]);                                            } else {                                                if (typeof xKeyData[1] != 'number') {                                                    if (typeof yKeyData[1] == 'number') {                                                        minTime = zKeyData[1];                                                    } else if (typeof zKeyData[1] == 'number') {                                                        minTime = yKeyData[1];                                                    } else {                                                        minTime = Math.min(yKeyData[1],zKeyData[1]);                                                    }                                                } else if (typeof yKeyData[1] == 'number') {                                                    if (typeof zKeyData[1] == 'number') {                                                        minTime = xKeyData[1];                                                    } else {                                                        minTime = Math.min(xKeyData[1],zKeyData[1]);                                                    }                                                } else {                                                    minTime = Math.min(xKeyData[1],yKeyData[1]);                                                }                                            }                                                                          keyTimeVar = minTime;                                            newIndex = i+1;                                            if (xKeyData[1] != minTime) {                                                isthereKeyX = false;                                                var newXValue = PropertyVal1.setValueAtTime(minTime, PropertyVal1.valueAtTime(minTime,true));                                                curXkey = PropertyVal1.valueAtTime(minTime,true);                                                xArray.insert(i,[curXkey,minTime]);                                            }                                            if (yKeyData[1] != minTime) {                                                isthereKeyY = false;                                                var newYValue = PropertyVal2.setValueAtTime(minTime, PropertyVal2.valueAtTime(minTime,true));                                                curYkey = PropertyVal2.valueAtTime(minTime,true);                                                yArray.insert(i,[curYkey,minTime]);                                            }                                            if (zKeyData[1] != minTime) {                                                isthereKeyZ = false;                                                var newZValue = PropertyVal3.setValueAtTime(minTime, PropertyVal3.valueAtTime(minTime,true));                                                curZkey = PropertyVal3.valueAtTime(minTime,true);                                                zArray.insert(i,[curZkey,minTime]);                                            }                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                    }                                }                                                               if (outofX == true || outofY == true || outofZ == true) {                                    if (IndexKey != totalKeys) {                                        IndexKey == totalKeys;                                    }                                }                            }                                                }                 }                                  return totalKeys;                  }                                                                function pasteKeyframestoJoin(PropertyVal, KeyArray){                    if(PropertyVal instanceof Property && KeyArray instanceof Array){                        if(PropertyVal.numKeys == 0){                                       var KeyArrayLength, addNewKey, newKeyIndex, newInEase, newOutEase;                               KeyArrayLength = KeyArray.length;                            isTrial = (!dhmK.s());                            for(var k = 0; k < KeyArrayLength; k++){                                     addNewKey = PropertyVal.addKey(KeyArray[k].keyTimeVar);                                       newKeyIndex = addNewKey;                                            PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKey);                                  if(KeyArray[k].keyInTypeX != KeyframeInterpolationType.BEZIER && KeyArray[k].keyInTypeY == KeyframeInterpolationType.BEZIER) {                                    newInEase = KeyArray[k].inEaseY;                                } else if(KeyArray[k].keyInTypeX == KeyframeInterpolationType.BEZIER && KeyArray[k].keyInTypeY != KeyframeInterpolationType.BEZIER) {                                    newInEase = KeyArray[k].inEase;                                } else {                                    newInEase = KeyArray[k].inEase;                                }                                if(KeyArray[k].keyOutTypeX != KeyframeInterpolationType.BEZIER && KeyArray[k].keyOutTypeY == KeyframeInterpolationType.BEZIER) {                                    newOutEase = KeyArray[k].OutEaseY;                                } else if(KeyArray[k].keyOutTypeX == KeyframeInterpolationType.BEZIER && KeyArray[k].keyOutTypeY != KeyframeInterpolationType.BEZIER) {                                    newOutEase = KeyArray[k].OutEase;                                } else {                                    newOutEase = KeyArray[k].OutEase;                                }                                if(KeyArray[k].keyOutTypeX != KeyframeInterpolationType.HOLD || KeyArray[k].keyOutTypeY != KeyframeInterpolationType.HOLD){                                    PropertyVal.setTemporalEaseAtKey(newKeyIndex, newInEase, newOutEase);                                }                                 if(KeyArray[k].keyOutTypeX != KeyframeInterpolationType.BEZIER && KeyArray[k].keyOutTypeY == KeyframeInterpolationType.BEZIER) {                                    PropertyVal.setInterpolationTypeAtKey(newKeyIndex, KeyArray[k].keyInTypeY, KeyArray[k].keyOutTypeY);                                    } else {                                    PropertyVal.setInterpolationTypeAtKey(newKeyIndex, KeyArray[k].keyInTypeX, KeyArray[k].keyOutTypeX);                                 }                                                                                if((KeyArray[k].keyInTypeX == KeyframeInterpolationType.BEZIER) && (KeyArray[k].keyOutTypeX == KeyframeInterpolationType.BEZIER)){                                    PropertyVal.setTemporalContinuousAtKey(newKeyIndex, KeyArray[k].ContBez);                                    PropertyVal.setTemporalAutoBezierAtKey(newKeyIndex, KeyArray[k].AutoBez);                                }                                  if((KeyArray[k].keyInTypeY == KeyframeInterpolationType.BEZIER) && (KeyArray[k].keyOutTypeY == KeyframeInterpolationType.BEZIER)){                                    PropertyVal.setTemporalContinuousAtKey(newKeyIndex, KeyArray[k].ContBez);                                    PropertyVal.setTemporalAutoBezierAtKey(newKeyIndex, KeyArray[k].AutoBez);                                }                                            if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                    PropertyVal.setSpatialContinuousAtKey(newKeyIndex, KeyArray[k].sContBez);                                    PropertyVal.setSpatialAutoBezierAtKey(newKeyIndex, KeyArray[k].sAutoBez);                                    PropertyVal.setSpatialTangentsAtKey(newKeyIndex, KeyArray[k].inSpaTang, KeyArray[k].OutSpaTang);                                }                            }                                               if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                for(var r = 1; r < KeyArrayLength; r++){                                    PropertyVal.setRovingAtKey((r), KeyArray[r].Rover);                                }                            }                            return true;                    }                    }                              }                function deleteKeyframes(PropertyVal){                    if(PropertyVal instanceof Property){                        while(PropertyVal.numKeys > 0){                            PropertyVal.removeKey(1);                        }                    }                }                var compLayer = app.project.activeItem;                var activeLayer = compLayer.selectedLayers;                if (activeLayer == null) {                    alert("Please select a layer");                    } else {                            if (isTrial) {                                alert("Joining keyframes is not supported in trial mode.\nPlease purchase a license to use full functionality");                            } else {                            for (var i=0; i<activeLayer.length; i++) {                                     var curLayer = activeLayer[i];                                   var oldKeys;                                   if (curLayer.property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated == false) {                                        alert("Position dimensions haven't been separated");                                   } else {                                       if (curLayer.property("ADBE Transform Group").property("ADBE Position").numKeys==0 && curLayer.property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated == true) {                                            curLayer.property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated = false;                                                                } else if (curLayer.property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated == true) {                                            if (curLayer.threeDLayer == true) {                                                oldKeys = getKeyframestoJoin (curLayer.property("ADBE Transform Group").property("ADBE Position"),true);                                            } else {                                                oldKeys = getKeyframestoJoin (curLayer.property("ADBE Transform Group").property("ADBE Position"),false);                                            }                                            curLayer.property("ADBE Transform Group").property("ADBE Position").dimensionsSeparated = false;                                            deleteKeyframes(curLayer.property("ADBE Transform Group").property("ADBE Position"));                                            pasteKeyframestoJoin(curLayer.property("ADBE Transform Group").property("ADBE Position"),oldKeys);                                        }                                    }                                }                            }                        }                app.endUndoGroup();            }            function separateScale() {                app.beginUndoGroup("Separate Scale Dimensions");                                function getKeyframes(PropertyVal){                    if(PropertyVal instanceof Property){                        var totalKeys, keyIndexList, IndexKey, ValueKey, keyInType, keyOutType, AutoBez, ContBez, inEase, OutEase, sAutoBez, sContBez, inSpaTang, OutSpaTang, Rover, twoDim, threeDim;                        twoDim = PropertyValueType.TwoD;                        threeDim = PropertyValueType.ThreeD;                        keyIndexList = [];                        totalKeys = PropertyVal.numKeys;                                   if(totalKeys > 0){                            for(var i = 1; i <= totalKeys; i++) {                                keyTimeVar = PropertyVal.keyTime(i);                                IndexKey = i;                                ValueKey = PropertyVal.keyValue(i);                                keyInType = PropertyVal.keyInInterpolationType(IndexKey);                                keyOutType = PropertyVal.keyOutInterpolationType(IndexKey);                                  if(keyInType == KeyframeInterpolationType.BEZIER && keyOutType == KeyframeInterpolationType.BEZIER){                                    AutoBez = PropertyVal.keyTemporalAutoBezier(IndexKey);                                    ContBez = PropertyVal.keyTemporalContinuous(IndexKey);                                }                                                        if(keyInType != KeyframeInterpolationType.HOLD || keyOutType != KeyframeInterpolationType.HOLD){                                    inEase = PropertyVal.keyInTemporalEase(IndexKey);                                    OutEase = PropertyVal.keyOutTemporalEase(IndexKey);                                }                                                                       keyIndexList[keyIndexList.length] = {                                    'keyTimeVar':keyTimeVar,                                     'IndexKey':IndexKey,                                     'ValueKeyX':ValueKey[0],                                     'ValueKeyY':ValueKey[1],                                    'ValueKeyZ':ValueKey[2],                                    'ValueKey':ValueKey,                                    'keyInType':keyInType,                                     'keyOutType':keyOutType,                                     'AutoBez':AutoBez,                                     'ContBez':ContBez,                                     'inEase':[inEase[0]],                                     'OutEase':[OutEase[0]],                                     'sAutoBez':sAutoBez,                                     'sContBez':sContBez,                                     'inSpaTang':inSpaTang,                                     'OutSpaTang':OutSpaTang,                                     'Rover':Rover                                    };                            }                                  return keyIndexList;                        }else{                                      return null;                        }                    }                }                function pasteKeyframes(PropertyVal, KeyArray,num){                    var XorYVal = num;                    if(PropertyVal instanceof Property && KeyArray instanceof Array){                        if(PropertyVal.numKeys == 0){                                 var KeyArrayLength, addNewKey, newKeyIndex;                                 KeyArrayLength = KeyArray.length;                              for(var k = 0; k < KeyArrayLength; k++){                                        addNewKey = PropertyVal.addKey(KeyArray[k].keyTimeVar);                                              newKeyIndex = addNewKey;                                            if (XorYVal == 0) {                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyX);                                  } else if (XorYVal == 1){                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyY);                                  } else {                                      PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKeyZ);                                }                                   if(KeyArray[k].keyOutType != KeyframeInterpolationType.HOLD){                                    PropertyVal.setTemporalEaseAtKey(newKeyIndex, KeyArray[k].inEase, KeyArray[k].OutEase);                                }                                    PropertyVal.setInterpolationTypeAtKey(newKeyIndex, KeyArray[k].keyInType, KeyArray[k].keyOutType);                                                               if((KeyArray[k].keyInType == KeyframeInterpolationType.BEZIER) && (KeyArray[k].keyOutType == KeyframeInterpolationType.BEZIER)){                                    PropertyVal.setTemporalContinuousAtKey(newKeyIndex, KeyArray[k].ContBez);                                    PropertyVal.setTemporalAutoBezierAtKey(newKeyIndex, KeyArray[k].AutoBez);                                }                                                                        if((PropertyVal.propertyValueType == PropertyValueType.TwoD) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD)){                                    PropertyVal.setSpatialContinuousAtKey(newKeyIndex, KeyArray[k].sContBez);                                    PropertyVal.setSpatialAutoBezierAtKey(newKeyIndex, KeyArray[k].sAutoBez);                                    PropertyVal.setSpatialTangentsAtKey(newKeyIndex, KeyArray[k].inSpaTang, KeyArray[k].OutSpaTang);                                }                            }                                   if((PropertyVal.propertyValueType == PropertyValueType.TwoD) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD)){                                for(var r = 0; r < KeyArrayLength; r++){                                    PropertyVal.setRovingAtKey((r+1), KeyArray[r].Rover);                                }                            }                            return true;                    }                }                }                function deleteKeyframes(PropertyVal){                    if(PropertyVal instanceof Property){                        while(PropertyVal.numKeys > 0){                            PropertyVal.removeKey(1);                        }                    }                }            var compLayer = app.project.activeItem;            var activeLayer = compLayer.selectedLayers;            var scaleLangs = {                en: "Scale",                fr: "Echelle",                de: "Skala",                es: "Escala",                it: "Scala",                jp: "スケール",                ko: "저울",                ru: "Масштаб"                };            var scaleLangName = localize(scaleLangs);            isTrial = (!dhmK.s());            if (activeLayer == null) {                alert("No layers selected");                } else {                    if (isTrial) {                        alert("The trial version is limited to "+trialLayerLimit+" layers at a time\nOnly the first "+trialLayerLimit+" layers will be separated");                        numLayers = trialLayerLimit;                    }                for (var i = 0; i<numLayers; i++) {                    var noDice = false;                    var curLayer = activeLayer[i];                    if (curLayer.property("ADBE Transform Group").property("ADBE Scale").expressionEnabled == true) {                        alert("Scale dimensions have already been separated with Keep 'Em Separated, or there is an existing expression on the Scale property. Please remove existing expressions and try again");                        noDice = true;                    } else {                        noDice = false;                    }                    if (noDice == false) {                        var threeD = false;                        var slider1 = curLayer.Effects.addProperty("ADBE Slider Control");                                                var xName = "X "+ scaleLangName;                        slider1.name = xName;                        var slider2 = curLayer.Effects.addProperty("ADBE Slider Control");                                                var yName = "Y " + scaleLangName;                        slider2.name = yName;                        if (curLayer.threeDLayer == true) {                            threeD = true;                            var slider3 = curLayer.Effects.addProperty("ADBE Slider Control");                                                        var zName = "Z " + scaleLangName;                            slider3.name = zName;                        }                        var scaleKeys = curLayer.property("ADBE Transform Group").property("ADBE Scale");                        if (scaleKeys.numKeys > 0) {                                                        var scaleOldKeys = getKeyframes (scaleKeys);                            deleteKeyframes(curLayer.property("ADBE Transform Group").property("ADBE Scale"));                            pasteKeyframes(curLayer.Effects.property(xName).property("ADBE Slider Control-0001"), scaleOldKeys,0);                            pasteKeyframes(curLayer.Effects.property(yName).property("ADBE Slider Control-0001"), scaleOldKeys,1);                            if (threeD == true) {                                pasteKeyframes(curLayer.Effects.property(zName).property("ADBE Slider Control-0001"), scaleOldKeys,2);                            }                                                    var expString = "[effect(\""+xName+"\")(\"Slider\"), effect(\""+yName+"\")(\"Slider\")]";                        curLayer.property("ADBE Transform Group").property("ADBE Scale").expression = expString;                        } else {                            var oldScaleVals = curLayer.property("ADBE Transform Group").property("ADBE Scale").valueAtTime(0,false);                            curLayer.Effects.property(xName).property("ADBE Slider Control-0001").setValue(oldScaleVals[0]);                            curLayer.Effects.property(yName).property("ADBE Slider Control-0001").setValue(oldScaleVals[1]);                            if (threeD == true) {                                curLayer.Effects.property(zName).property("ADBE Slider Control-0001").setValue(oldScaleVals[2]);                            }                            var expString = "[effect(\""+xName+"\")(\"Slider\"), effect(\""+yName+"\")(\"Slider\")]";                            curLayer.property("ADBE Transform Group").property("ADBE Scale").expression = expString;                        }                    }                }                app.endUndoGroup();            }            }            function joinScale() {                app.beginUndoGroup("Join Scale Dimensions");                                                Array.prototype.insert = function ( index, item ) {                this.splice( index, 0, item );            };                                function getKeyframestoJoin(PropertyVal1, PropertyVal2, PropertyVal3){                        var totalKeys, curXkey, curYkey, curZkey, prop, keyIndexList, keyTimeVar2, IndexKey, newIndex, ValueKey, keyInTypeX, keyInTypeY, keyInTypeZ, keyOutTypeX, keyOutTypeY, keyOutTypeZ, AutoBezX, AutoBezY, AutoBezZ, ContBezX, ContBezY, ContBezZ, inEaseX,  inEaseY,  inEaseZ, OutEaseX, OutEaseY, OutEaseZ,                         sAutoBezX, sAutoBezY, sAutoBezZ, sContBezX, sContBezY, sContBezZ, inSpaTangX, inSpaTangY, inSpaTangZ, OutSpaTangX, OutSpaTangY, OutSpaTangZ, RoverX,  RoverY, RoverZ, twoDim, threeDim;                        twoDim = PropertyValueType.TwoD_SPATIAL;                        threeDim = PropertyValueType.ThreeD_SPATIAL;                        keyIndexList = [];                        var threeD = false;                        if (PropertyVal3 == 0) {                            totalKeys = Math.max(PropertyVal1.numKeys, PropertyVal2.numKeys);                            var xArray = [], yArray = [];                        } else {                            totalKeys = Math.max(PropertyVal1.numKeys, PropertyVal2.numKeys, PropertyVal3.numKeys);                            var xArray = [], yArray = [], zArray = [];                            threeD = true;                        }                        if(totalKeys > 0){                            for (var x = 1; x <= PropertyVal1.numKeys; x++) {                                xArray.push([PropertyVal1.keyValue(x), PropertyVal1.keyTime(x)]);                            }                            for (var y = 1; y <= PropertyVal2.numKeys; y++) {                                yArray.push([PropertyVal2.keyValue(y),PropertyVal2.keyTime(y)]);                            }                            if (threeD == true) {                                for (var z = 1; z <= PropertyVal3.numKeys; z++) {                                    zArray.push([PropertyVal3.keyValue(z),PropertyVal3.keyTime(z)]);                                }                            }                            if (xArray != null && yArray != null) {                            for (i = 0; i < totalKeys; i++) {                                                 var xKeyData = xArray[i];                                var yKeyData = yArray[i];                                if (threeD == true) {                                    var zKeyData = zArray[i];                                } else {                                    var zKeyData = null;                                }                                IndexKey = i+1;                                var isthereKeyX = false, isthereKeyY = false, isthereKeyZ = false, outofX = false, outofY = false, outofZ = false;                                try {                                    var trial = xArray.length <= i;                                    trial == false;                                    typeof xKeyData[1] !== undefined;                                } catch(err) {                                    outofX = true;                                }                                try {                                    var trial = yArray.length <= i;                                    trial == false;                                    typeof yKeyData[1] !== undefined;                                } catch(err) {                                    outofY = true;                                }                                if (threeD == true) {                                    try {                                        var trial = zArray.length <= i;                                        trial == false;                                        typeof zKeyData[1] !== undefined;                                    } catch(err) {                                        outofZ = true;                                    }                                }                                var newXValue, newYValue, newZValue;                                if (threeD == false) {                                    if (outofX == true || outofY == true) {                                       if (outofX == true) {                                                                          keyTimeVar = yKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = false;                                            isthereKeyY = true;                                                                           newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                            curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                                                          xArray.insert(i, [curXkey,yKeyData[1]]);                                                                         ValueKey = [curXkey, yKeyData[0]];                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal1.keyOutInterpolationType(newIndex);                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                       } else if (outofY == true) {                                                                      keyTimeVar = xKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = false;                                                                        newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1],true));                                                                       curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                                                        yArray.insert(i, [curYkey,xKeyData[1]]);                                                                       ValueKey = [xKeyData[0], curYkey];                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal1.keyOutInterpolationType(newIndex);                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                          }                                    } else {                                                                    if (xKeyData[1] == yKeyData[1]) {                                            ValueKey = [xKeyData[0],yKeyData[0]];                                            keyTimeVar = xKeyData[1];                                                                          newIndex = i+1;                                                   keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                         } else if (xKeyData[1] > yKeyData[1]) {                                            newIndex = i+1;                                            isthereKeyX = false;                                            isthereKeyY = true;                                            keyTimeVar = yKeyData[1];                                            newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                            curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                            xArray.insert(i, [curXkey,yKeyData[1]]);                                            ValueKey = [curXkey, yKeyData[0]];                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                            totalKeys= Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                        } else if (yKeyData[1] > xKeyData[1]) {                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = false;                                            keyTimeVar = xKeyData[1];                                            newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1],true));                                            curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                            yArray.insert(i, [curYkey,xKeyData[1]]);                                            ValueKey = [xKeyData[0], curYkey];                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                            totalKeys= Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys);                                      }                                                                              }                                } else {                                    if (outofX == true || outofY == true || outofZ == true) {                                       if (outofX == true) {                                           if (outofY == false && outofZ == false) {                                                                                                                    keyTimeVar = yKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = false;                                                isthereKeyY = true;                                                isthereKeyZ = true;                                                                                newXValue = PropertyVal1.setValueAtTime(yKeyData[1],PropertyVal1.valueAtTime(yKeyData[1], true));                                                curXkey = PropertyVal1.valueAtTime(yKeyData[1], true);                                                                                xArray.insert(i, [curXkey,yKeyData[1]]);                                                                                ValueKey = [curXkey, yKeyData[0],zKeyData[0]];                                                keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                                keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                                 keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                                keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                                keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                                keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                                totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                           } else if (outofY == true && outofZ == false) {                                                                             keyTimeVar = zKeyData[1];                                               newIndex = i+1;                                               isthereKeyX = false;                                               isthereKeyY = false;                                               isthereKeyZ = true;                                               newXValue = PropertyVal1.setValueAtTime(zKeyData[1],PropertyVal1.valueAtTime(zKeyData[1],true));                                               newYValue = PropertyVal2.setValueAtTime(zKeyData[1],PropertyVal2.valueAtTime(zKeyData[1],true));                                               curXkey = PropertyVal1.valueAtTime(zKeyData[1], true);                                               curYkey = PropertyVal2.valueAtTime(zKeyData[1], true);                                               xArray.insert(i,[curXkey,zKeyData[1]]);                                               yArray.insert(i,[curYkey,zKeyData[1]]);                                               ValueKey = [curXkey,curYkey,zKeyData[0]];                                               keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                               keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                                keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                               keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                               keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                               keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                               totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                       } else if (outofY == true) {                                           if (outofZ == false) {                                                                                  keyTimeVar = zKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = true;                                                isthereKeyY = false;                                                isthereKeyZ = true;                                                                                  newXValue = PropertyVal1.setValueAtTime(zKeyData[1],PropertyVal1.valueAtTime(zKeyData[1],true));                                                curXkey = PropertyVal1.valueAtTime(zKeyData[1],true);                                                newYValue = PropertyVal2.setValueAtTime(zKeyData[1],PropertyVal2.valueAtTime(zKeyData[1], true));                                                curYkey = PropertyVal2.valueAtTime(zKeyData[1], true);                                                                              xArray.insert(i,[curXkey,zKeyData[1]]);                                                yArray.insert(i, [curYkey,zKeyData[1]]);                                                                                  ValueKey = [curXkey,curYkey, zKeyData[0]];                                                keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                                keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                                 keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                                keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                                keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                                keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                                totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          } else {                                                                                   keyTimeVar = xKeyData[1];                                                newIndex = i+1;                                                isthereKeyX = true;                                                isthereKeyY = false;                                                isthereKeyZ = false;                                                newYValue = PropertyVal2.setValueAtTime(xKeyData[1],PropertyVal2.valueAtTime(xKeyData[1], true));                                                newZValue = PropertyVal3.setValueAtTime(xKeyData[1],PropertyVal3.valueAtTime(xKeyData[1], true));                                                curYkey = PropertyVal2.valueAtTime(xKeyData[1],true);                                                curZkey = PropertyVal3.valueAtTime(xKeyData[1],true);                                                yArray.insert(i,[curYkey,xKeyData[1]]);                                                zArray.insert(i,[curZkey,xKeyData[1]]);                                                ValueKey = [xKeyData[0],curYkey,curZkey];                                                keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                                keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                                 keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                                keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                                keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                                keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                                totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                       } else {                                                                           keyTimeVar = xKeyData[1];                                            newIndex = i+1;                                            isthereKeyX = true;                                            isthereKeyY = true;                                            isthereKeyZ = false;                                                                         newZValue = PropertyVal3.setValueAtTime(xKeyData[1],PropertyVal3.valueAtTime(xKeyData[1],true));                                                                        curZkey = PropertyVal3.valueAtTime(xKeyData[1],true);                                                                        zArray.insert(i, [curZkey,xKeyData[1]]);                                                                       ValueKey = [xKeyData[0], yKeyData[0],curZkey];                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                            keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                            keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                        }                                                                                } else {                                          if (xKeyData[1] == yKeyData[1] == zKeyData[1]) {                                            ValueKey = [xKeyData[0],yKeyData[0],zKeyData[0]];                                            keyTimeVar = xKeyData[1];                                                                        newIndex = i+1;                                                   keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                             keyInTypeZ = PropertyVal3.keyInInterpolationType(newIndex);                                            keyOutTypeZ = PropertyVal3.keyOutInterpolationType(newIndex);                                        } else {                                                               var notNum = false;                                            try {                                                typeof xKeyData[1] != 'undefined';                                                                               typeof yKeyData[1] != 'undefined';                                                                                   typeof zKeyData[1] != 'undefined';                                                                              } catch(err) {                                                notNum = true;                                            }                                                                      var minTime = 0;                                            if (notNum == false) {                                                minTime = Math.min(xKeyData[1], yKeyData[1], zKeyData[1]);                                            } else {                                                if (typeof xKeyData[1] != 'number') {                                                    if (typeof yKeyData[1] == 'number') {                                                        minTime = zKeyData[1];                                                    } else if (typeof zKeyData[1] == 'number') {                                                        minTime = yKeyData[1];                                                    } else {                                                        minTime = Math.min(yKeyData[1],zKeyData[1]);                                                    }                                                } else if (typeof yKeyData[1] == 'number') {                                                    if (typeof zKeyData[1] == 'number') {                                                        minTime = xKeyData[1];                                                    } else {                                                        minTime = Math.min(xKeyData[1],zKeyData[1]);                                                    }                                                } else {                                                    minTime = Math.min(xKeyData[1],yKeyData[1]);                                                }                                            }                                                                                       keyTimeVar = minTime;                                            newIndex = i+1;                                            if (xKeyData[1] != minTime) {                                                isthereKeyX = false;                                                newXValue = PropertyVal1.setValueAtTime(minTime, PropertyVal1.valueAtTime(minTime,true));                                                curXkey = PropertyVal1.valueAtTime(minTime,true);                                                xArray.insert(i,[curXkey,minTime]);                                            }                                            if (yKeyData[1] != minTime) {                                                isthereKeyY = false;                                                newYValue = PropertyVal2.setValueAtTime(minTime, PropertyVal2.valueAtTime(minTime,true));                                                curYkey = PropertyVal2.valueAtTime(minTime,true);                                                yArray.insert(i,[curYkey,minTime]);                                            }                                            if (zKeyData[1] != minTime) {                                                isthereKeyZ = false;                                                newZValue = PropertyVal3.setValueAtTime(minTime, PropertyVal3.valueAtTime(minTime,true));                                                curZkey = PropertyVal3.valueAtTime(minTime,true);                                                zArray.insert(i,[curZkey,minTime]);                                            }                                            ValueKey = [PropertyVal1.valueAtTime(minTime,true), PropertyVal2.valueAtTime(minTime,true), PropertyVal3.valueAtTime(minTime,true)]                                            keyInTypeX = PropertyVal1.keyInInterpolationType(newIndex);                                            keyOutTypeX = PropertyVal1.keyOutInterpolationType(newIndex);                                             keyInTypeY = PropertyVal2.keyInInterpolationType(newIndex);                                            keyOutTypeY = PropertyVal2.keyOutInterpolationType(newIndex);                                            totalKeys = Math.max(PropertyVal1.numKeys,PropertyVal2.numKeys,PropertyVal3.numKeys);                                          }                                    }                                }                                if (outofX == true || outofY == true || outofZ == true) {                                    if (IndexKey != totalKeys) {                                        IndexKey == totalKeys;                                    }                                }                                                                                       if(keyInTypeX == KeyframeInterpolationType.BEZIER && keyOutTypeX == KeyframeInterpolationType.BEZIER){                                    AutoBezX = PropertyVal1.keyTemporalAutoBezier(IndexKey);                                    ContBezX = PropertyVal1.keyTemporalContinuous(IndexKey);                                 }                                if (keyInTypeY == KeyframeInterpolationType.BEZIER && keyOutTypeY == KeyframeInterpolationType.BEZIER) {                                    AutoBezY = PropertyVal2.keyTemporalAutoBezier(IndexKey);                                    ContBezY = PropertyVal2.keyTemporalContinuous(IndexKey);                                }                                if (threeD == true) {                                    if (keyInTypeZ == KeyframeInterpolationType.BEZIER && keyOutTypeZ == KeyframeInterpolationType.BEZIER) {                                    AutoBezZ = PropertyVal2.keyTemporalAutoBezier(IndexKey);                                    ContBezZ = PropertyVal2.keyTemporalContinuous(IndexKey);                                 }                                } else {                                     AutoBezZ = 0;                                     ContBezZ = 0;                                 }                                                                          if(keyInTypeX != KeyframeInterpolationType.HOLD || keyOutTypeX != KeyframeInterpolationType.HOLD){                                    inEaseX = PropertyVal1.keyInTemporalEase(IndexKey);                                    OutEaseX = PropertyVal1.keyOutTemporalEase(IndexKey);                                 }                                 if(keyInTypeY != KeyframeInterpolationType.HOLD || keyOutTypeY != KeyframeInterpolationType.HOLD){                                    inEaseY = PropertyVal2.keyInTemporalEase(IndexKey);                                    OutEaseY = PropertyVal2.keyOutTemporalEase(IndexKey);                                 }                                 if(threeD == true) {                                    if(keyInTypeZ != KeyframeInterpolationType.HOLD || keyOutTypeZ != KeyframeInterpolationType.HOLD){                                        inEaseZ = PropertyVal3.keyInTemporalEase(IndexKey);                                        OutEaseZ = PropertyVal3.keyOutTemporalEase(IndexKey);                                 }                                  } else {                                     inEaseZ = 0;                                     OutEaseZ = 0;                                 }                                if(PropertyVal1.propertyValueType == twoDim || PropertyVal1.propertyValueType == threeDim){                                    sAutoBezX = PropertyVal1.keySpatialAutoBezier(IndexKey);                                    sContBezX = PropertyVal1.keySpatialContinuous(IndexKey);                                    inSpaTangX = PropertyVal1.keyInSpatialTangent(IndexKey);                                    OutSpaTangX = PropertyVal1.keyOutSpatialTangent(IndexKey);                                    RoverX = PropertyVal1.keyRoving(IndexKey);                                }                                if(PropertyVal2.propertyValueType == twoDim || PropertyVal2.propertyValueType == threeDim){                                    sAutoBezY = PropertyVal2.keySpatialAutoBezier(IndexKey);                                    sContBezY = PropertyVal2.keySpatialContinuous(IndexKey);                                    inSpaTangY = PropertyVal2.keyInSpatialTangent(IndexKey);                                    OutSpaTangY = PropertyVal2.keyOutSpatialTangent(IndexKey);                                    RoverY = PropertyVal2.keyRoving(IndexKey);                                }                                if(threeD == true) {                                    if(PropertyVal3.propertyValueType == twoDim || PropertyVal3.propertyValueType == threeDim){                                        sAutoBezZ = PropertyVal3.keySpatialAutoBezier(IndexKey);                                        sContBezZ = PropertyVal3.keySpatialContinuous(IndexKey);                                        inSpaTangZ = PropertyVal3.keyInSpatialTangent(IndexKey);                                        OutSpaTangZ = PropertyVal3.keyOutSpatialTangent(IndexKey);                                        RoverZ = PropertyVal3.keyRoving(IndexKey);                                    }                                } else {                                    sAutoBezZ = 0;                                    sContBezZ = 0;                                    inSpaTangZ = 0;                                    OutSpaTangZ = 0;                                    RoverZ = 0;                                }                                keyIndexList[keyIndexList.length] = {                                    'keyTimeVar':keyTimeVar,                                     'IndexKey':IndexKey,                                     'ValueKeyX':ValueKey[0],                                     'ValueKeyY':ValueKey[1],                                    'ValueKeyZ':ValueKey[2],                                    'ValueKey':ValueKey,                                    'keyInType':keyInTypeX,                                     'keyOutType':keyOutTypeX,                                    'keyInTypeY':keyInTypeY,                                     'keyOutTypeY':keyOutTypeY,                                    'keyInTypeZ':keyInTypeZ,                                    'keyOutTypeZ':keyOutTypeZ,                                    'AutoBezX':AutoBezX,                                    'AutoBezY':AutoBezY,                                    'AutoBezZ':AutoBezZ,                                    'ContBezX':ContBezX,                                     'ContBezY':ContBezY,                                    'ContBezZ':ContBezZ,                                     'inEaseX':inEaseX,                                     'inEaseY':inEaseY,                                    'inEaseZ':inEaseZ,                                    'OutEaseX':OutEaseX,                                    'OutEaseY':OutEaseY,                                     'OutEaseZ':OutEaseZ,                                     'sAutoBezX':sAutoBezX,                                     'sAutoBezY':sAutoBezY,                                     'sAutoBezZ':sAutoBezZ,                                     'sContBezX':sContBezX,                                     'sContBezY':sContBezY,                                    'sContBezZ':sContBezZ,                                    'inSpaTangX':inSpaTangX,                                     'inSpaTangY':inSpaTangY,                                     'inSpaTangZ':inSpaTangZ,                                     'OutSpaTangX':OutSpaTangX,                                     'OutSpaTangY':OutSpaTangY,                                     'OutSpaTangZ':OutSpaTangZ,                                     'RoverX':RoverX,                                    'RoverY':RoverY,                                    'RoverZ':RoverZ,                                    'threeD':threeD                                    };                            }                                     return keyIndexList;                }            }            }                function pasteKeyframestoJoin(PropertyVal, KeyArray){                        if(PropertyVal.numKeys == 0){                                       var KeyArrayLength, newkeyTimeVar, addNewKey, newKeyIndex, keyInX, keyInY, keyInZ, keyOutX, keyOutY, keyOutZ;                                    KeyArrayLength = KeyArray.length;                                isTrial = (!dhmK.s());                            for(var k = 0; k < KeyArrayLength; k++){                                                    addNewKey = PropertyVal.addKey(KeyArray[k].keyTimeVar);                                       newKeyIndex = addNewKey;                                            PropertyVal.setValueAtKey(newKeyIndex, KeyArray[k].ValueKey);                                keyInX = KeyArray[k].inEaseX[0];                                keyInY = KeyArray[k].inEaseY[0];                                keyOutX = KeyArray[k].OutEaseX[0];                                keyOutY = KeyArray[k].OutEaseY[0];                                if (KeyArray[k].threeD == true) {                                    keyInZ = KeyArray[k].inEaseZ[0];                                    keyOutZ = KeyArray[k].OutEaseZ[0];                                }                                if(KeyArray[k].keyOutTypeX != KeyframeInterpolationType.HOLD){                                     if (KeyArray[k].threeD == true) {                                        PropertyVal.setTemporalEaseAtKey(newKeyIndex, [keyInX,keyInY,keyInZ], [keyOutX,keyOutY,keyOutZ]);                                     } else {                                         PropertyVal.setTemporalEaseAtKey(newKeyIndex, [keyInX,keyInY,keyInY], [keyOutX,keyOutY,keyOutY]);                                     }                                }                                   PropertyVal.setInterpolationTypeAtKey(newKeyIndex, KeyArray[k].keyInType, KeyArray[k].keyOutType);                                                              if((KeyArray[k].keyInTypeX == KeyframeInterpolationType.BEZIER) && (KeyArray[k].keyOutTypeX == KeyframeInterpolationType.BEZIER)){                                    PropertyVal.setTemporalContinuousAtKey(newKeyIndex, KeyArray[k].ContBezX);                                    PropertyVal.setTemporalAutoBezierAtKey(newKeyIndex, KeyArray[k].AutoBezX);                                }                                                              if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                    PropertyVal.setSpatialContinuousAtKey(newKeyIndex, KeyArray[k].sContBezX);                                    PropertyVal.setSpatialAutoBezierAtKey(newKeyIndex, KeyArray[k].sAutoBezX);                                    PropertyVal.setSpatialTangentsAtKey(newKeyIndex, KeyArray[k].inSpaTangX, KeyArray[k].OutSpaTangX);                                }                            }                                               if((PropertyVal.propertyValueType == PropertyValueType.TwoD_SPATIAL) || (PropertyVal.propertyValueType == PropertyValueType.ThreeD_SPATIAL)){                                for(var r = 0; r < KeyArrayLength; r++){                                    PropertyVal.setRovingAtKey((r+1), KeyArray[r].RoverX);                                }                            }                            return true;                       }                }                function alertScreen(PropertyVal) {                    for (x=0; x <PropertyVal.length; x++) {                       var property = PropertyVal[x];                       alert("Value Key "+x+" is");                       alert(property.ValueKey);                     }                 }                function deleteKeyframes(PropertyVal){                        while(PropertyVal.numKeys > 0){                            PropertyVal.removeKey(1);                       }                }                var compLayer = app.project.activeItem;                var activeLayer = compLayer.selectedLayers;                isTrial = (!dhmK.s());                if (activeLayer == null) {                    alert("Please select a layer");                    } else {                        if (isTrial) {                            alert("Joining Scale is not supported in trial mode.\nPlease purchase a license to experience full functionality of Keep 'Em Separated");                        } else {                        for (var d=0; d<activeLayer.length; d++) {                             var curLayer = activeLayer[d];                            var exists = false;                            var threeD = false;                            if (curLayer.threeDLayer == true) {                                threeD = true;                            }                            try {                                curLayer.property("ADBE Transform Group").property("ADBE Scale").expressionEnabled == true;                                curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001");                                curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001");                                typeof curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001") != 'undefined';                                typeof curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001") != 'undefined';                                exists = true;                            } catch(err) {                                                   exists = false;                            }                            if (exists == false) {                                alert("Layer hasn't had its Scale property separated yet. Please separate Scale with Keep 'Em Separated and try again");                            } else {                               if (curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001").numKeys==0 && curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001").numKeys==0) {                                    var slideValX = curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001").value;                                    var slideValY = curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001").value;                                    if (threeD == true) {                                        var slideValZ = curLayer.Effects.property("Z Scale").property("ADBE Slider Control-0001").value;                                        curLayer.Effects.property("Z Scale").remove();                                    }                                    curLayer.property("ADBE Transform Group").property("ADBE Scale").expression = '';                                     curLayer.Effects.property("X Scale").remove();                                    curLayer.Effects.property("Y Scale").remove();                                    if (threeD == false) {                                        curLayer.property("ADBE Transform Group").property("ADBE Scale").setValue([slideValX,slideValY]);                                    } else {                                        curLayer.property("ADBE Transform Group").property("ADBE Scale").setValue([slideValX,slideValY,slideValZ]);                                    }                            } else {                               if (threeD == false) {                                    var oldKeys = getKeyframestoJoin (curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001"), curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001"),0);                                } else {                                    var oldKeys = getKeyframestoJoin (curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001"), curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001"),curLayer.Effects.property("Z Scale").property("ADBE Slider Control-0001"));                                    deleteKeyframes(curLayer.Effects.property("Z Scale").property("ADBE Slider Control-0001"));                                    curLayer.Effects.property("Z Scale").remove();                                }                                                  deleteKeyframes(curLayer.Effects.property("X Scale").property("ADBE Slider Control-0001"));                                deleteKeyframes(curLayer.Effects.property("Y Scale").property("ADBE Slider Control-0001"));                                curLayer.property("ADBE Transform Group").property("ADBE Scale").expression = '';                                curLayer.Effects.property("X Scale").remove();                                curLayer.Effects.property("Y Scale").remove();                                pasteKeyframestoJoin(curLayer.property("ADBE Transform Group").property("ADBE Scale"),oldKeys);                            }                                                     }                                                }                    }                }                app.endUndoGroup();            }             }        }	   }        dhm_KES(this); //pass 'this' so you can use it to build a dockable UI